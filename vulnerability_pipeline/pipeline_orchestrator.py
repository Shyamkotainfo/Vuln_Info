import argparse
import sys
import logging


# Setup Logging
logging.basicConfig(
    level=logging.WARNING,  # Changed from INFO to reduce logs
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler("pipeline.log"),
        logging.StreamHandler(sys.stdout)
    ]
)
logger = logging.getLogger("pipeline.orchestrator")
logger.setLevel(logging.INFO)  # Keep orchestrator at INFO for progress tracking

# Import Sources dynamically
import importlib
import pkgutil
import os
from .core.config import Config

class PipelineOrchestrator:
    def __init__(self):
        self.bronze_sources = self._discover_sources()
        self.silver_sources = self._discover_silver_pipelines()
        self.gold_mirrors = self._discover_gold_pipelines("mirrors")

    # ... (omitted) ...

    def _run_gold(self, source_keys=None):
        # 1. Run Mirrors (Sync Silver -> Gold Source)
        mirror_keys = source_keys if source_keys else self.gold_mirrors.keys()
        for key in mirror_keys:
            if key in self.gold_mirrors:
                logger.info(f"--- Running Gold Mirror: {key.upper()} ---")
                try:
                    self.gold_mirrors[key].run()
                except Exception as e:
                    logger.error(f"Gold Mirror {key} failed: {e}", exc_info=True)

    def _discover_sources(self):
        sources = {}
        # Path to bronze package
        try:
            import vulnerability_pipeline.bronze as bronze_pkg
            path = os.path.dirname(bronze_pkg.__file__)
            
            for _, name, is_pkg in pkgutil.iter_modules([path]):
                if is_pkg:
                    try:
                        module = importlib.import_module(f"vulnerability_pipeline.bronze.{name}")
                        if hasattr(module, "Extractor") and hasattr(module, "Loader") and hasattr(module, "INCREMENTAL_KEY"):
                            logger.info(f"Discovered Bronze source: {name}")
                            # Initialize extractor
                            if name == "nvd":
                                extractor = module.Extractor(api_key=Config.NVD_API_KEY)
                            else:
                                extractor = module.Extractor()
                                
                            sources[name] = {
                                "extractor": extractor,
                                "loader": module.Loader(),
                                "key": module.INCREMENTAL_KEY
                            }
                        else:
                            logger.debug(f"Skipping {name}: Missing Extractor/Loader/INCREMENTAL_KEY export.")
                    except Exception as e:
                        logger.error(f"Error loading Bronze source {name}: {e}")
        except Exception as e:
            logger.error(f"Error discovering Bronze sources: {e}")
        return sources

    def _discover_silver_pipelines(self):
        pipelines = {}
        try:
            import vulnerability_pipeline.silver as silver_pkg
            path = os.path.dirname(silver_pkg.__file__)
            
            for _, name, is_pkg in pkgutil.iter_modules([path]):
                if is_pkg:
                    try:
                        module = importlib.import_module(f"vulnerability_pipeline.silver.{name}")
                        if hasattr(module, "Pipeline"):
                            logger.info(f"Discovered Silver pipeline: {name}")
                            pipelines[name] = module.Pipeline() # Instantiate
                    except Exception as e:
                        logger.error(f"Error loading Silver pipeline {name}: {e}")
        except Exception as e:
            logger.error(f"Error discovering Silver pipelines: {e}")
        return pipelines

    def _discover_gold_pipelines(self, sub_package):
        pipelines = {}
        try:
            import vulnerability_pipeline.gold as gold_pkg
            base_path = os.path.dirname(gold_pkg.__file__)
            target_path = os.path.join(base_path, sub_package)
            
            if not os.path.exists(target_path):
                return {}

            for _, name, is_pkg in pkgutil.iter_modules([target_path]):
                if is_pkg:
                    try:
                        module = importlib.import_module(f"vulnerability_pipeline.gold.{sub_package}.{name}")
                        if hasattr(module, "Pipeline"):
                            logger.info(f"Discovered Gold {sub_package} pipeline: {name}")
                            pipelines[name] = module.Pipeline()
                    except Exception as e:
                        logger.error(f"Error loading Gold {sub_package} pipeline {name}: {e}")
        except Exception as e:
            logger.error(f"Error discovering Gold {sub_package} pipelines: {e}")
        return pipelines

    def run_pipeline(self, source_keys=None, layer="all"):
        """
        Runs the pipeline.
        :param source_keys: List of source names (e.g. nvd, cisa).
        :param layer: 'bronze', 'silver', 'gold', or 'all'.
        """
        # Bronze Layer
        if layer in ["bronze", "all"]:
            logger.info("=== Starting Bronze Layer ===")
            self._run_bronze(source_keys)
            
        # Silver Layer
        if layer in ["silver", "all"]:
             logger.info("=== Starting Silver Layer ===")
             self._run_silver(source_keys)

        # Gold Layer
        if layer in ["gold", "all"]:
            logger.info("=== Starting Gold Layer ===")
            self._run_gold(source_keys)

    def _run_bronze(self, source_keys=None):
        keys_to_run = source_keys if source_keys else self.bronze_sources.keys()
        
        for key in keys_to_run:
            if key not in self.bronze_sources:
                logger.warning(f"Source {key} not found. Skipping.")
                continue
            
            logger.info(f"--- Running Bronze: {key.upper()} ---")
            components = self.bronze_sources[key]
            try:
                # Determine start point
                loader = components["loader"]
                extractor = components["extractor"]
                max_key_field = components["key"]
                
                last_val = loader.get_max_key(max_key_field)
                
                # Validation logic for corrupt keys
                start_val = None
                if last_val:
                    if isinstance(last_val, str) and (',' in last_val or 'score_date' in last_val):
                         logger.warning(f"Found invalid key: {last_val}. Full refresh.")
                    else:
                         logger.info(f"Resuming from {last_val}")
                         start_val = last_val
                
                if not start_val:
                    if key == "nvd": start_val = "1999-01-01T00:00:00.000"
                    else: start_val = "1970-01-01"
                
                extractor_gen = extractor.extract(since=start_val)
                loader.load(extractor_gen)
                
            except Exception as e:
                logger.error(f"Bronze {key} failed: {e}", exc_info=True)

    def _run_silver(self, source_keys):
        keys_to_run = source_keys if source_keys else self.silver_sources.keys()
        for key in keys_to_run:
            if key not in self.silver_sources:
                continue
                
            logger.info(f"--- Running Silver: {key.upper()} ---")
            try:
                pipeline = self.silver_sources[key]
                pipeline.run()
            except Exception as e:
                logger.error(f"Silver {key} failed: {e}", exc_info=True)

    def _run_gold(self, source_keys=None):
        # 1. Run Mirrors (Sync Silver -> Gold Source)
        mirror_keys = source_keys if source_keys else self.gold_mirrors.keys()
        for key in mirror_keys:
            if key in self.gold_mirrors:
                logger.info(f"--- Running Gold Mirror: {key.upper()} ---")
                try:
                    self.gold_mirrors[key].run()
                except Exception as e:
                    logger.error(f"Gold Mirror {key} failed: {e}", exc_info=True)
        

def main():
    parser = argparse.ArgumentParser(description="Vulnerability ETL Pipeline Orchestrator")
    parser.add_argument("--sources", nargs="+", help="Specific sources to run (nvd, cisa, etc)")
    parser.add_argument("--layer", choices=["bronze", "silver", "gold", "all"], default="all", help="Which layer to run")
    
    args = parser.parse_args()
    
    orchestrator = PipelineOrchestrator()
    orchestrator.run_pipeline(source_keys=args.sources, layer=args.layer)

if __name__ == "__main__":
    main()
