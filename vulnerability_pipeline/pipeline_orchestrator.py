import argparse
import sys
import logging
from datetime import datetime

# Setup Logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler("pipeline.log"),
        logging.StreamHandler(sys.stdout)
    ]
)
logger = logging.getLogger("pipeline.orchestrator")

# Import Sources
from .bronze.nvd.extract import NVDExtractor
from .bronze.nvd.load import NVDLoader
from .bronze.cisa.extract import CISAExtractor
from .bronze.cisa.load import CISALoader
from .bronze.epss.extract import EPSSExtractor
from .bronze.epss.load import EPSSLoader
from .bronze.exploit.extract import ExploitDBExtractor
from .bronze.exploit.load import ExploitDBLoader
from .bronze.metasploit.extract import MetasploitExtractor
from .bronze.metasploit.load import MetasploitLoader

from .core.config import Config

class PipelineOrchestrator:
    def __init__(self):
        self.sources = {
            "nvd": {"extractor": NVDExtractor(api_key=Config.NVD_API_KEY), "loader": NVDLoader(), "key": "lastModified"},
            "cisa": {"extractor": CISAExtractor(), "loader": CISALoader(), "key": "dateAdded"}, # or catalogVersion
            "epss": {"extractor": EPSSExtractor(), "loader": EPSSLoader(), "key": "date"},
            "exploit": {"extractor": ExploitDBExtractor(), "loader": ExploitDBLoader(), "key": "date_published"},
            "metasploit": {"extractor": MetasploitExtractor(), "loader": MetasploitLoader(), "key": "mod_time"},
        }

    def run_pipeline(self, source_keys=None, mode="full"):
        """
        Runs the pipeline for specified sources.
        :param source_keys: List of source names.
        :param mode: Deprecated, but kept for CLI compat. Logic is now always incremental-ish (since date).
        """
        keys_to_run = source_keys if source_keys else self.sources.keys()
        
        # Default start dates for different sources (if DB is empty)
        # NVD uses ISO datetime
        # Others use YYYY-MM-DD
        
        for key in keys_to_run:
            if key not in self.sources:
                logger.warning(f"Unknown source: {key}")
                continue
            
            logger.info(f"--- Starting {key.upper()} Pipeline ---")
            components = self.sources[key]
            extractor = components["extractor"]
            loader = components["loader"]
            max_key_field = components["key"]
            
            # Determine start point
            last_ingested_val = loader.get_max_key(max_key_field)
            
            start_val = None
            if last_ingested_val:
                # Validate the key if it's EPSS or similar date-based
                # Simple check: if it contains comma or 'v' prefix where not expected?
                # User reported: "v2025.03.14,score_date"
                if isinstance(last_ingested_val, str) and (',' in last_ingested_val or 'score_date' in last_ingested_val):
                    logger.warning(f"Found invalid incremental key in DB: {last_ingested_val}. Ignoring and doing full refresh.")
                    start_val = None
                else:
                    logger.info(f"Found existing data. Resuming from {last_ingested_val}")
                    start_val = last_ingested_val
            
            if not start_val:
                logger.info("No valid existing data found in Bronze. Starting full load from default epoch.")
                if key == "nvd":
                    start_val = "1999-01-01T00:00:00.000" # Approximate start of CVE era
                else:
                    start_val = "1970-01-01"

            try:
                # Extract returns a generator/iterator
                data_generator = extractor.extract(since=start_val)
                
                # Load consumes the iterator
                loader.load(data_generator)
                
            except Exception as e:
                logger.error(f"Pipeline failed for {key}: {e}", exc_info=True)
            
            logger.info(f"--- Completed {key.upper()} Pipeline ---")

def main():
    parser = argparse.ArgumentParser(description="Vulnerability ETL Pipeline Orchestrator")
    parser.add_argument("--sources", nargs="+", help="Specific sources to run (nvd, cisa, epss, exploit, metasploit)")
    parser.add_argument("--mode", choices=["full", "incremental"], default="full", help="Load mode")
    
    args = parser.parse_args()
    
    orchestrator = PipelineOrchestrator()
    orchestrator.run_pipeline(source_keys=args.sources, mode=args.mode)

if __name__ == "__main__":
    main()
