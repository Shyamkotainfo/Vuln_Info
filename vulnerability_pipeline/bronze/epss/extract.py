import requests
import csv
import gzip
from datetime import datetime
from vulnerability_pipeline.core.base_etl import BaseExtractor

class EPSSExtractor(BaseExtractor):
    def __init__(self):
        super().__init__("EPSS")
        self.url = "https://epss.cyentia.com/epss_scores-current.csv.gz"

    def extract(self, since=None):
        try:
            print("Fetching EPSS data...")
            response = requests.get(self.url, timeout=60, stream=True)
            response.raise_for_status()
            
            # Since EPSS is a single file snapshot, "incremental" based on rows isn't easy without date in file.
            # However, the file typically has a comment #model_version:v2023.03.01, #score_date:2024-12-09
            # checking the date in comment is best way to see if we need to process it.
            
            # Decompress on the fly
            with gzip.open(response.raw, mode='rt', encoding='utf-8') as f:
                # Read metadata lines
                score_date = None
                lines_iterator = iter(f)
                
                # We need to peek/consume lines to find metadata and header
                # Since we can't easily peek generator, we will iterate.
                
                # Usually first line is model version, second is score date
                # We will read until we hit header (not starting with #)
                
                header_found = False
                fieldnames = None
                
                # We handle the iteration manually to capture metadata
                # Then yield dicts
                
                # Strategy: collect lines until header
                meta_lines = []
                # Reconstruct a generator? 
                
                # Simpler: just read line by line.
                
                import re
                
                # Strategy: Read lines until header (first non-comment line)
                # Parse metadata using regex to be robust against "key:val,key2:val" formats
                
                for line in lines_iterator:
                    line = line.strip()
                    if not line:
                        continue 
                        
                    if line.startswith('#'):
                        # Metadata comment (e.g. #score_date:2024-12-09 or joined with model_version)
                        # Look for score_date:YYYY-MM-DD
                        match = re.search(r'score_date:(\d{4}-\d{2}-\d{2})', line)
                        if match:
                            score_date = match.group(1)
                    else:
                        # This is the header line (e.g., cve,epss,percentile)
                        fieldnames = line.split(',')
                        header_found = True
                        break
                
                if not header_found or not fieldnames:
                    print("EPSS header not found.")
                    return

                # Validate score_date format
                if score_date:
                    try:
                        # Just ensure it looks like a date or keep string
                        # Usually YYYY-MM-DD
                        pass
                    except:
                         pass
                
                # Logical check
                if since and score_date:
                    if score_date <= since:
                        print(f"Skipping EPSS load. Score date {score_date} <= since {since}")
                        return

                if not fieldnames:
                    print("EPSS header not found.")
                    return

                print(f"Processing EPSS for date: {score_date}")
                
                reader = csv.DictReader(lines_iterator, fieldnames=fieldnames)
                for row in reader:
                    # Enrich with date here
                    row['date'] = score_date if score_date else datetime.utcnow().strftime("%Y-%m-%d")
                    yield row
                    
        except Exception as e:
            print(f"Error extracting EPSS data: {e}")
            return []
